---
description: Core Formatting & TypeScript Patterns
alwaysApply: true
---

# Core Formatting & TypeScript Patterns

## ESLint & Prettier Configuration

### Core Setup

- **ESLint**: Configured for TypeScript, React, and accessibility (`jsx-a11y`).
- **Prettier**: Handles all code formatting automatically.
- **Integration**: `eslint-config-prettier` disables ESLint rules that conflict with Prettier.

### Key ESLint Rules

- `@typescript-eslint/no-explicit-any`: **Error**. Avoid `any` type.
- `@typescript-eslint/explicit-function-return-type`: **Warn**. Encourage explicit return types.
- `react/react-in-jsx-scope`: **Off**. Not needed with modern React.
- `react/prop-types`: **Off**. TypeScript interfaces are used instead.
- `no-console`: **Warn** in development, **Error** in production.

## TypeScript Best Practices

### Typing

- **Prefer `interface` over `type` for objects and classes**: They can be extended.
- **Use `type` for primitives, unions, and tuples**.
- **Avoid `any`**: Use `unknown` for values with unknown types and perform type checking.

```typescript
// ✅ GOOD: Using interface for an object
interface User {
    id: number;
    name: string;
}

// ✅ GOOD: Using type for a union
type Status = 'loading' | 'success' | 'error';

// ❌ BAD: Using any
const processData = (data: any) => {
    console.log(data.name); // Unsafe
};

// ✅ GOOD: Using unknown
const processDataSafely = (data: unknown) => {
    if (typeof data === 'object' && data !== null && 'name' in data) {
        console.log((data as { name: string }).name); // Safe
    }
};
```

### Generics

- Use generics to create reusable, type-safe components and functions.

```typescript
// Generic API response component
interface ApiResponse<T> {
    data: T;
    status: number;
}

function handleResponse<T>(response: ApiResponse<T>): T {
    return response.data;
}

// Generic state hook
function useData<T>(initialData: T) {
    const [data, setData] = useState<T>(initialData);
    return { data, setData };
}
```

## Import Order

- A consistent import order improves readability. Use a plugin like `@trivago/prettier-plugin-sort-imports` to automate this.

```typescript
// 1. React & framework imports
import React, { useState, useEffect } from 'react';

// 2. External library imports
import { cva } from 'class-variance-authority';
import { motion } from 'framer-motion';

// 3. Internal absolute imports (from aliases like @/)
import { Button } from '@/components/ui/button';
import { useAuth } from '@/hooks/useAuth';
import type { User } from '@/types';

// 4. Relative imports
import { localHelper } from './utils';

// 5. Type imports
import type { VariantProps } from 'class-variance-authority';

// 6. Styles/Assets
import './styles.css';
```

## TSX Formatting

### Props

- **Multiline Props**: One prop per line, indented.
- **Boolean Props**: Use shorthand (e.g., `disabled` instead of `disabled={true}`).

```tsx
// ✅ GOOD
<MyComponent
    title="Welcome"
    user={currentUser}
    onSave={handleSave}
    disabled
/>

// ❌ BAD
<MyComponent title="Welcome" user={currentUser} onSave={handleSave} disabled={true} />
```

### Conditional Rendering

- **Simple Conditions**: Use `&&` for toggling elements.
- **If/Else Conditions**: Use the ternary operator `? :`.
- **Complex Conditions**: Extract logic into a function or variable for clarity.

```tsx
// ✅ Simple toggle
{
    isLoading && <Spinner />;
}

// ✅ If/Else
{
    user ? <UserProfile user={user} /> : <LoginButton />;
}

// ✅ Complex logic extracted
const renderStatus = () => {
    if (isError) return <ErrorState />;
    if (isLoading) return <LoadingState />;
    return <DataDisplay data={data} />;
};

return <div>{renderStatus()}</div>;
```

### Tailwind CSS Class Sorting

- Use the official Prettier plugin for Tailwind CSS (`prettier-plugin-tailwindcss`) to automatically sort classes in a consistent order.

```jsx
// Before (unsorted)
<div class="text-white px-4 font-bold bg-blue-500 py-2 rounded-md"></div>

// After (sorted by Prettier plugin)
<div class="rounded-md bg-blue-500 px-4 py-2 font-bold text-white"></div>
```

## Error Handling & Debugging

### Error Boundaries

- Wrap major sections of the UI in Error Boundaries to prevent a single component error from crashing the entire app.

```typescript
// components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from "react";

interface Props {
  children: ReactNode;
  fallback: ReactNode;
}

interface State {
  hasError: boolean;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = { hasError: false };

  public static getDerivedStateFromError(_: Error): State {
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo);
    // You can also log the error to an error reporting service here
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}

// Usage in App.tsx
<ErrorBoundary fallback={<ErrorScreen />}>
  <MainApp />
</ErrorBoundary>
```

### Console Logging Strategy

- Use structured console logs to make debugging easier.

```typescript
// ✅ GOOD
console.group('Auth Flow Step: Login');
console.log('Credentials:', credentials);
console.log('Timestamp:', new Date().toISOString());
console.groupEnd();

console.error({
    source: 'APIController',
    method: 'login',
    error: new Error('Invalid credentials'),
    timestamp: new Date().toISOString(),
});

// ❌ BAD
console.log('login');
console.log(error);
```
